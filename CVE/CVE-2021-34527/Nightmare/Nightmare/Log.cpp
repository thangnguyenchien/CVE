#include "pch.h"

#include <stdio.h>
#include <stdlib.h>
#include "Nightmare.h"
#include "DynLibResolver.h"
#include "MemOps.h"
#include "StringCrypt.h"
#include "Log.h"

#ifdef _USELOG
#define LARGE_LOG_BUFFER_LEN 1024

static const CHAR*  szLogFileName = "nm_log.txt\0";
static CHAR*        g_log_buf;

BOOL InitLog(PLogger Logger)
{
    CHAR sTempPath[MAX_PATH];
    mem_set((PBYTE)sTempPath, MAX_PATH, 0);

    /* DWORD cbTempPathLen = ((fp_GetTempPathA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
         XorDecryptString(p_FunctionTable[FunctionEntry::_GetTempPathA])))(MAX_PATH + 1, sTempPath);

     if (!cbTempPathLen) {
         return FALSE;
     }*/

    DecryptConfig(&g_public_profile);

    mem_cpy((PBYTE)g_public_profile.pszDecrypted, (PBYTE)sTempPath, str_len(g_public_profile.pszDecrypted));
    mem_cpy((PBYTE)szLogFileName, (PBYTE)((ULONGLONG)sTempPath + str_len(sTempPath)), str_len((CHAR*)szLogFileName));

    if ((Logger->hLogFile = ((fp_CreateFileA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_CreateFileA])))(sTempPath,
            GENERIC_WRITE,
            0,
            NULL,
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL)) == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }
    return TRUE;
}

static BOOL _Log(PLogger Logger, const char* prefix, const char* fmt, va_list vl)
{
    DWORD dwError = 0;
    DWORD dwFileWrite;
    DWORD dwBufferWrite;

    g_log_buf = (CHAR*)malloc(LARGE_LOG_BUFFER_LEN);

    if (Logger->hLogFile == NULL && g_log_buf) return FALSE;

    mem_set((PBYTE)g_log_buf, 1024, 0);
    mem_cpy((PBYTE)prefix, (PBYTE)g_log_buf, str_len((CHAR*)prefix));

    CHAR* tmp_buf = g_log_buf + str_len(g_log_buf);
    wvsprintfA(tmp_buf, fmt, vl);
    dwBufferWrite = str_len(g_log_buf);

    if (!((fp_WriteFile)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_WriteFile])))(Logger->hLogFile, g_log_buf, dwBufferWrite, &dwFileWrite, NULL))
    {
        return FALSE;
    }

    free(g_log_buf);

    return TRUE;
}

BOOL Log(PLogger Logger, const CHAR* prefix, const CHAR* fmt, ...)
{
    BOOL bRet = TRUE;
    va_list vl;
    va_start(vl, fmt);
    bRet = _Log(Logger, prefix, fmt, vl);
    va_end(vl);
    return TRUE;
}

static const char* prf_info = "[+] ";
BOOL LogInfo(PLogger Logger, const CHAR* fmt, ...)
{
    BOOL bRet = TRUE;
    va_list vl;
    va_start(vl, fmt);
    bRet = _Log(Logger, prf_info, fmt, vl);
    va_end(vl);
    return TRUE;
}

BOOL LogClose(PLogger Logger)
{
    if (Logger->hLogFile == NULL) return TRUE;
    return  ((fp_CloseHandle)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_CloseHandle])))(Logger->hLogFile);
}

#endif