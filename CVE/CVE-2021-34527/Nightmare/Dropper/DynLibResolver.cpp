#include <windows.h>
#include <winnt.h>
#include <winternl.h>
#include <assert.h>
#include <stdlib.h>
#include "StringCrypt.h"
#include "DynLibResolver.h"
#pragma warning(2:4235)

DWORD mbyte_2_wchar(char* p_mbyte, DWORD cbByte, WCHAR* p_wchar, DWORD cbWchar)
{
    DWORD i;
    if (cbByte != cbWchar)
    {
        return -1;
    }
    for (i = 0; i < cbByte;i++)
    {
        SHORT c = *(PBYTE)(p_mbyte + i);
        *(SHORT*)(p_wchar + i) = c;
    }
    return i;
}

BOOL InitFuncResolver()
{
    char* sKernel32 = XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]);
    WCHAR* wsKernel32 = (WCHAR*)malloc(2 * sizeof(p_ModuleTable[ModuleEntry::_Kernel32]));
    
    if (!mbyte_2_wchar(sKernel32, sizeof(p_ModuleTable[ModuleEntry::_Kernel32]), wsKernel32, sizeof(p_ModuleTable[ModuleEntry::_Kernel32])))
    {
        return FALSE;
    }
    
    void* kernel32 = myGetModuleHandleW(wsKernel32);
    free(wsKernel32);

    if (kernel32 == NULL)
    {
        return FALSE;
    }

    char* pszGetProcAddress = XorDecryptString(p_FunctionTable[FunctionEntry::_GetProcAddress]);
    _fGetProcAddress = (fp_GetProcAddress)myGetProcAddress((char*)kernel32, pszGetProcAddress);

    if (_fGetProcAddress == NULL)
    {
        return FALSE;
    }

    char* pszLoadLibraryA = XorDecryptString(p_FunctionTable[FunctionEntry::_LoadLibraryA]);
    _fLoadLibraryA = (fp_LoadLibraryA)_fGetProcAddress((HMODULE)kernel32, pszLoadLibraryA);

    if (_fLoadLibraryA == NULL)
    {
        return FALSE;
    }

    free(pszGetProcAddress);
    free(pszLoadLibraryA);
    return TRUE;
}

VOID* ResolveModuleFunction(char* module, char* functionName)
{
    assert(_fLoadLibraryA && _fGetProcAddress);

    HMODULE l_module = _fLoadLibraryA(module);
    if (l_module == NULL)
    {
        return NULL;
    }
    VOID* p_func = _fGetProcAddress(l_module, functionName);

    free(module);
    free(functionName);

    return p_func ? p_func : NULL;
}

// ### Necesasry functions ###

int string_cmp(char* cmp, char* other) {
    /* char* string comparison, return true/false */
    while (*other == *cmp && *other != 0) {
        cmp++;
        other++;
    }
    return (*cmp == *other);
}

int wstring_cmp_i(WCHAR* cmp, WCHAR* other) {
    /* Case insensitive Wstring compare, cmp must be lowercase.
    returns true/false */
    WORD* w_cmp = (WORD*)cmp;
    WORD* w_other = (WORD*)other;
    while (*w_other != 0) {
        WORD lowercase_other = ((*w_other >= 'A' && *w_other <= 'Z')
            ? *w_other - 'A' + 'a'
            : *w_other);
        if (*w_cmp != lowercase_other) {
            return 0;
        }
        w_cmp++;
        w_other++;
    }
    return (*w_cmp == 0);
}

void* myGetModuleHandleW(WCHAR* module_name) {
    /* Find module by readin the PEB.
    module_name must be lowerstring */

    // Get the PEB address from the TEB
    PEB* PEB_ptr = NULL;
    /*_asm 
    {
        mov eax, fs:[0x30];
        mov PEB_ptr, eax;
    }*/
#ifdef _WIN64
    PEB_ptr = (PEB*)__readgsqword(0x60);
#else
    PEB_ptr = (PEB*)__readfsdword(0x30);
#endif

    if (PEB_ptr == NULL) 
    {
        return NULL;
    }

    // Get to the module linked list
    PEB_LDR_DATA* peb_ldr_data = PEB_ptr->Ldr;
    LIST_ENTRY* list_head = &(peb_ldr_data->InMemoryOrderModuleList);
    LIST_ENTRY* list_entry;
    LDR_DATA_TABLE_ENTRY_COMPLETED* ldr_entry;

    // goes through the linked list to find kernel32.dll
    // stops when return to header element (the list head is linked to the tail)
    for (list_entry = list_head->Flink; list_entry != list_head; list_entry = list_entry->Flink) {
        // We follow inMemoryOrder, so list_entry points to LDR_DATA_TABLE_ENTRY_COMPLETED.InMemoryOrderLinks
        // We need to remove the size of the first element to get the address of the object
        ldr_entry = (LDR_DATA_TABLE_ENTRY_COMPLETED*)((char*)list_entry - sizeof(LIST_ENTRY));
        WCHAR* name = ldr_entry->BaseDllName.Buffer;
        if (wstring_cmp_i(module_name, name)) {
            return ldr_entry->DllBase;
        }
    }
    return NULL;
}

void* myGetProcAddress(char* module, char* search_name) {
    /* Find an exported function in a module, by name */

    // Get to the export table
    IMAGE_DOS_HEADER* p_DOS_HDR = (IMAGE_DOS_HEADER*)module;
    IMAGE_NT_HEADERS* p_NT_HDR = (IMAGE_NT_HEADERS*)(((char*)p_DOS_HDR) + p_DOS_HDR->e_lfanew);
    IMAGE_EXPORT_DIRECTORY* export_directory = (IMAGE_EXPORT_DIRECTORY*)(module +
        p_NT_HDR->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    // Get the arrays based on their RVA in the IMAGE_EXPORT_DIRECTORY struct
    DWORD* names_RVA_array = (DWORD*)(module + export_directory->AddressOfNames);
    DWORD* function_RVA_array = (DWORD*)(module + export_directory->AddressOfFunctions);
    WORD* name_ordinals_array = (WORD*)(module + export_directory->AddressOfNameOrdinals);

    //Then for each function
    for (int i = 0; i < export_directory->NumberOfFunctions; ++i) {
        // Get the functions ordinal, name and code RVA
        //DWORD exported_ordinal = name_ordinals_array[i] + export_directory->Base;
        char* funct_name = module + names_RVA_array[i];
        DWORD exported_RVA = function_RVA_array[name_ordinals_array[i]];

        if (string_cmp(search_name, funct_name)) {
            return (void*)(module + exported_RVA);
        }
    }
    return NULL;
}